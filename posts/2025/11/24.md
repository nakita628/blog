---
date: 2025-11-24
title: TypeScript 関数オーバーロード
description: 関数オーバーロード
tags: 
    - TypeScript
prev:
    text: TypeScript never型
    link: /posts/2025/11/23
next:
    text: TypeScript インデックスシグネチャ
    link: /posts/2025/11/25
---

# TypeScript 関数オーバーロード

## addNumbers関数の実装

:::code-group
```ts [index.ts]
function addNumbers(a: number | string, b: number | string) {
  if (typeof a === 'number' && typeof b === 'number') {
    return a + b
  } else {
    return a.toString() + b.toString()
  }
}

const result = addNumbers("1", "2")

result.includes('1')
// プロパティ 'includes' は型 'string | number' に存在しません。
// プロパティ 'includes' は型 'number' に存在しません。
```
:::

&emsp;上記の例の、`addNumbers`関数では、パラメータ`a`と`b`の型、そして戻り値の方はすべて`number | string`というユニオン型。関数内では、`typeof`演算子を用いた`if`文で引数の型をチェックし、量引数が数値の場合には加算をお粉、それ以外の場合には文字列として結合する処理をしている。

&emsp;しかし、このアプローチには問題がある。関数に文字列を渡したときに戻り値に対して`string`型のメソッドを使用しようとすると、`TypeScript`はエラーを発生させる。その理由は、`TypeScript`が`addNumbers`関数の戻り値を`number | string`と推論しており、戻り値が`number`の可能性もあるため、`string`型専用のメソッドを安全に呼び出すことができないと判断するから。

&emsp;この問題を解決するために、`TypeScript`では**関数オーバーロード**を使用する。関数オーバーロードを用いると、同じ名前の関数に対して複数の呼び出しシグネチャを定義可能。これにより、関数の呼び出し方法に応じて、`TypeScript`コンパイラによる型推論をより正確に行わせることが可能。


## 関数オーバーロード

:::code-group
```ts [index.ts]
// オーバーロードのシグネチャ
function addNumbers(a: number, b: number): number
function addNumbers(a: string, b: string): string
function addNumbers(a: number, b: string): string
function addNumbers(a: string, b: number): string

function addNumbers(a: number | string, b: number | string): number | string {
  if (typeof a === 'number' && typeof b === 'number') {
    return a + b
  } else {
    return a.toString() + b.toString()
  }
}

const result = addNumbers('1', '2') // result は string 型として推論される
// string 型と推論されているためエラーにならない
result.includes('1') // true
```
:::