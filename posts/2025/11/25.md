---
date: 2025-11-25
title: TypeScript インデックスシグネチャ
description: インデックスシグネチャ
tags: 
    - TypeScript
prev:
    text: TypeScript 関数オーバーロード
    link: /posts/2025/11/24
next:
    text: TypeScript インターフェイス
    link: /posts/2025/11/26
---

# TypeScript インデックスシグニチャ

## インデックスシグニチャの構文

[キーの名前(任意) : キーの型]: 値の型

:::code-group
```ts [index.ts]
interface FruitStock {
  [i: string]: number
}

// アクセスされるキーがstring型であるとき、常にnumber型の値を返すという構造を表現している。

const fruit: FruitStock = {}
fruit.apple = 3
fruit.orange = 5

// fruit.banana = 'many'
// 型 'string' を型 'number' に割り当てることはできません。
```
:::

## テンプレート文字列リテラル

:::code-group
```ts [index.ts]
interface Product {
  [key: `product_${number}`]: string
}

const productA: Product = {
  product_1: 'foo',
  product_2: 'bar',
  product_10: 'baz',
}

const productB: Product = {
  product_1: 'foo',
  product_2: 'bor',
  // product_dx: 'baz', // Error
  // オブジェクト リテラルは既知のプロパティのみ指定できます。'product_dx' は型 'Product' に存在しません。
}
```
:::

&emsp;上記の例では、`productB`の`product_dx`というキーは`Product`インターフェイスのインデックスシグニチャのパターンに合致していないため、`TypeScript`はエラーを報告する。

&emsp;`TypeScript`において、遺ンデックスシグニチャで型定義されたオブジェクトにおいては、定義されていないプロパティへのアクセスがコンパイル時にエラーとならず、実行時には`undefined`となる。これはインデックスシグニチャがオブジェクトが任意のプロパティ名を持つ可能性があると宣言しているため。

&emsp;インデックスシグニチャは便利な機能だが、オブジェクトのプロパティがあらかじめ定義できる場合は、より具体的なプロパティの型定義を使用した方が適切。いンデックスシグニチャは、動的にプロパティ名が変わる可能性がある場合や、外部のデータソース(APIの応答など)を扱う際に、プロパティ名が事前に定義されていないオブジェクトを型付けするのに最も適している。
