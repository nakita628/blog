---
date: 2025-11-27
title: TypeScript 型同士の関係
description: 型同士の関係
tags: 
    - TypeScript
prev:
    text: TypeScript インターフェイス
    link: /posts/2025/11/26
next:
    text: TypeScript サブタイプとスーパータイプ
    link: /posts/2025/11/28
---

# TypeScript 型同士の関係

&emsp;型とはデータを分類した時の種類のこと。データを分類するという行為は、すべてのデータの集まりの間に線を引いて、一部のまとまりを、共通の特徴を持つ「型」として区別していく作業。

&emsp;型の場合は、分類の対象がデータの集まりだが、一般的に「もの」の集まりは**集合**という概念で定義することができ、集合を構成する個々のものは**要素**と呼ばれる。

## 数値リテラル型のユニオン型

:::code-group
```ts [index.ts]
// 特定の数値のみをメンバーにもつユニオン型を定義
type JpnCoin = 1 | 5 | 10 | 50 | 100 | 500
type UsCoin = 1 | 5 | 10 | 25
```
:::

&emsp;上記の例では、特定の数値リテラル型をメンバーに持つユニオン型を2つ定義している。それぞれのユニオン型は、限定された数値だけを要素とする集合とみなせる。たとえば`JpnCoin`型は、1、5、10、50、100、500という特定の数値リテラル型を要素としてもち、`JpnCoin`型に属すると同時に、より広い範囲の`number`型にも属するという性質を持つ。

&emsp;以上のことから、特定のリテラルのみを含むユニオン型は、`number`型の集合内に、別の小さな集合を形成していると言える。このように、ある集合Aの中に、特定の要素だけを持つ小さな集合Bが存在する時、その集合Bを集合Aの**部分集合**(subset)と呼ぶ。一方、この時の集合Aは集合Bの**上位集合**(superset)という。`JpnCoin`型と`UsCoin`型は、どちらも`number`型の部分集合に該当する。

## 型(集合)同士の演算

:::code-group
```ts [index.ts]
type JpnCoin = 1 | 5 | 10 | 50 | 100 | 500
type UsCoin = 1 | 5 | 10 | 25
// 集合同士の演算
// ユニオン型
type UnionCoin = JpnCoin | UsCoin
// 100 | 1 | 5 | 10 | 50 | 500 | 25
// インターセクション型
type IntersectionCoin = JpnCoin & UsCoin
// 1 | 5 | 10
```
:::

&emsp;上記の例では、`UnionCoin`型は、`JpnCoin`と`UsCoin`を包含するより大きな集合となり、`IntersectionCoin`型は`JpnCoin`と`UsCoin`の共通部分を表す部分集合として現れる。

## 異なるプリミティブ型同士の演算

:::code-group
```ts [index.ts]
// ユニオン型
type NumberOrString = number | string
// インターセクション型
type NumberAndString = number & string // never
```
:::

&emsp;上記の例では`NumberOrString`型は、`number`型の集合と`string`型の集合を合体させた集合であり、これによって数値と文字列の両方を要素として包む集合が形成される。対照的に、`NumberAndString`型は`number`型と`string`型の両方の属性を同時に持つ要素の集合を示すが、そのような要素は実際に存在しないため、この型はからの集合を表す。空の集合は**空集合**と呼ばれ、`TypeScript`では、`never`型として扱われる。空集合は定義上、すべての集合の部分集合となる。

## オブジェクト型と集合

:::code-group
```ts [index.ts]
// string型のnameプロパティを持つオブジェクト型を定義
type Name = {
  name: string
}

let john: Name

const objA = { name: 'John' }
john = objA // OK. nameプロパティが存在するため

const objB = { name: 'John', gender: 'male' }

john = objB // OK. name以外のプロパティが含まれていても代入可能。つまり、objBはName型の要素。

const objC = {
  fullName: 'John Doe',
  age: 25,
}

// john = objC
// プロパティ 'name' は型 '{ fullName: string; age: number; }' にありませんが、型 'Name' では必須です。
```

&emsp;上記の例では、3種類のオブジェクトを定義してそれぞれ`Name`型の変数`john`に代入している。

- 1つ目の`objA`は`string`型の`name`プロパティのみを持つオブジェクト。`Name`型の要素なので代入可能。

- 2つ目の`objB`は`name`以外のプロパティを持つが、条件を満たすのでこのオブジェクトも代入可能。`objB`は`name`プロパティに加えて追加のプロパティを持っているが、`Name`型の要件を満たしているため代入は許される。ただし、過剰プロパティチェックにより、オブジェクトリテラルを直接変数に代入するとエラーが発生するので注意。

- 3つ目の`objC`は必要な`name`プロパティを持っていないため、代入は型エラーになる。

## オブジェクト型同士のユニオン型の変数とオブジェクトの代入

:::code-group
```ts [index.ts]
type Name = {
  name: string
}

type Age = {
  age: number
}

// ユニオン型を定義
type NameOrAge = Name | Age
// { name: string } | { age: number }

let john: NameOrAge
john = { name: 'John' } // OK
john = { age: 20 } // OK
```
:::

&emsp;上記の例では、`number`型の`age`プロパティを持つ`Age`型を定義している。次に、`NameOrAge`型として、`Age`型と`Name`型のユニオン型を定義して、その型を変数`john`に指定する。

&emsp;`john`は、`string`型の`name`プロパティを持つオブジェクト、あるいは`number`型の`age`プロパティを持つオブジェクトのいずれかを受け入れることができる。両方のプロパティを持つオブジェクトや、追加のプロパティを含むオブジェクトも代入可能。

## オブジェクト型同士のインターセクション型の変数とオブジェクトの代入

:::code-group
```ts [index.ts]
type Name = {
  name: string
}

type Age = {
  age: number
}

// インターセクション型
type NameAndAge = Name & Age
// { name: string; age: number }

let alice: NameAndAge
alice = {
  name: 'Alice',
  age: 30,
}

// alice = {
//   name: 'Alice'
// }
// 型 '{ name: string; }' を型 'NameAndAge' に割り当てることはできません。
// プロパティ 'age' は型 '{ name: string; }' にありませんが、型 'Age' では必須です。
```

&emsp;上記の例では、`Name`型と`Age`型の属性を組み合わせたインターセクション型`NameAndAge`型を定義。この型の変数`alice`には、`string`型の`name`プロパティと`number`型の`age`プロパティの両方を含んだオブジェクトのみが代入可能。`name`プロパティのみを含むオブジェクトは、`age`プロパティが欠けているため代入できない。