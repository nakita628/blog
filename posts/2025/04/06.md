---
date: 2025-04-19
title: Clean Architecture 構造化プログラミング
description: Clean Architecture 構造化プログラミング
tags: 
    - Clean Architecture
prev:
    text: Clean Architecture パラダイム
    link: ../05
next:
    text: Clean Architecture オブジェクト指向プログラミング
    link: ../07
---

# Clean Architecture 構造化プログラミング

&emsp;プログラムは「順次」「選択」「反復」の3つの構造で構築できる。
&emsp;この発見が決定的なもの。モジュールを証明可能にする制御構造は、あらゆるプログラムを構築できる制御構造の最小セットと同じであった。

## 機能分割

&emsp;構造化プログラミングは、モジュールを証明可能な単位に再起的に分割する事を可能にする。それによって、モジュールは機能的に分割できる。つまり、大きな問題は上位レベルの機能に分割できる。分割された機能は、さらに下位レベルの機能へと無限に分割していくことができる。また、このように分割された機能は、構造化プログラミングの制限された制御構造を使用して表現することが可能。

&emsp;大きな問題をモジュールやコンポーネントに分割し、さらに小さな証明可能な機能へと分割していった。

## テスト

**テストはバグが存在しないことではなく、バグが存在することを示すものである**

&emsp;テストによってプログラムが正しくないことは証明できるが、プログラムが正しいことは証明できない。テストに十分な労力をかけていれば、そのプログラムは目的のために十分に真であるとみなせる。

&emsp;構造化プログラミングでは、プログラムを再起的に分割して、証明可能な小さな機能にする必要がある。そして、証明可能な小さな機能が正しくないことを、テストを使って証明する。テストが正しくないことを証明できなければ、その機能は目的のために十分にー正しいとみなすことができる。

## まとめ

&emsp;構造化プログラミングの価値を高めるのは、反証可能なプログラミングの単位を生成する能力。アーキテクチャレベルにおいて、**機能分割**がベストプラクティスだと考えられている理由。

&emsp;最小の機能から最大のコンポーネントまで、あらゆるレベルにおいて、ソフトウェアは科学のように、反証可能性によって動かされている。ソフトウェアアーキテクトは、簡単に反証できる(テスト可能な)モジュール、コンポーネント、サービスを定義しようとする。そのため、さらに上位のレベルにおいて、構造化プログラミングのような制限を課している。