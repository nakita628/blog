---
date: 2025-12-01
title: TypeScript 関数型
description: 関数型
tags: 
    - TypeScript
prev:
    text: TypeScript 複雑な型と互換性
    link: /posts/2025/11/30
next:
    false
---

# TypeScript 関数型

## 戻り値の型

&emsp;パラメータの型が互換性を有する2つの関数AとBにおいて、もし「Bの戻り値の型 <: Aの戻り値の型」の関係が成り立つならば、関数Bは関数Aのサブタイプとして見なされる。


## 戻り値の型と関数型の互換性

:::code-group
```ts [index.ts]
let fn1 = () => ({ name: 'John' })
// 関数型: () => { name: string }

const fn2 = () => ({ name: 'John', age: 30 })
// 関数型: () => { name: string, age: number }

// OK
fn1 = fn2
// fn2の戻り値 <: fn1の戻り値の型 であるため、fn1にfn2が代入可能

// NG
// fn2 = fn1
// 型 '() => { name: string; }' を型 '() => { name: string; age: number; }' に割り当てることはできません。
// プロパティ 'age' は型 '{ name: string; }' にありませんが、型 '{ name: string; age: number; }'
```
:::

## パラメータの型

&emsp;戻り値の型が互換性を持つ2つの関数AとBを考えた場合、以下の条件を満たすときに、関数Bは関数Aのサブタイプとなる。

- 対応する各パラメータにおいて、「Aのパラメータの型 <: Bのパラメータの型」である。
- Bのパラメータ数 <= Aのパラメータ数

&emsp;1つ目の条件には注意が必要。なぜなら、オブジェクト型の互換性で見た関係とは逆なため。オブジェクトの場合は、オブジェクトの「各プロパティの型がサブタイプ」であれば、そのオブジェクト自体もサブタイプになる。

&emsp;一方、関数型の場合は、関数Bのパラメータの型が、関数Aのパラメータの型のスーパータイプであれば、関数Bは関数Aのサブタイプとなる。

:::code-group
```ts [index.ts]
interface Person {
  name: string
  age: number
}

// インターフェイスの拡張によって、自動的にStudentはPersonのサブタイプになる
interface Student extends Person {
  club: string
}

// Studentインターフェイスの構造
// {
//   name: string
//   age: number
//   club: string
// }
```
:::

&emsp;上記の例では、`Person`インターフェイスを拡張して`Student`インターフェイスを定義している。この拡張によって、`Student`インターフェイスは、`Person`インターフェイスが持つすべてのプロパティの他に、追加で`club`プロパティを持つことになり、「`Student` <: `Person`」というサブタイプ関係が自然に成立。

## パラメータの型と関数型の互換性

:::code-group
```ts [index.ts]
interface Person {
  name: string
  age: number
}

// インターフェイスの拡張によって、自動的にStudentはPersonのサブタイプになる
interface Student extends Person {
  club: string
}

// Studentインターフェイスの構造
// {
//   name: string
//   age: number
//   club: string
// }

let fn3 = (person: Person) => {
  console.log(`That person's name is ${person.name} (${person.age})`)
}
// fn3 は関数型: (person: Person) => void

let fn4 = (student: Student) => {
  console.log(
    `That student's name is ${student.name} (${student.age}) and enjoys ${student.club} club`,
  )
}
// fn4 は関数型: (student: Student) => void

// NG
// パラメータの型に注目すると、Student型 <: Person型 なので条件を満たさない
// fn3 = fn4
// 型 '(student: Student) => void' を型 '(person: Person) => void' に割り当てることはできません。
// パラメーター 'student' および 'person' は型に互換性がありません。
// プロパティ 'club' は型 'Person' にありませんが、型 'Student' では必須です。

// OK
fn4 = fn3

// fn4のパラメータの型はStudent型のため、Student型のオブジェクトを渡す必要がある。
fn4({ name: 'John', age: 20, club: 'Soccer' }) // OK

// fn4({ name: 'John', age: 20 }) // NG
// 型 '{ name: string; age: number; }' の引数を型 'Student' のパラメーターに割り当てることはできません。
// プロパティ 'club' は型 '{ name: string; age: number; }' にありませんが、型 'Student' では必須です。
```
:::

&emsp;上記の例では、`fn3`と`fn4`は、どちらも同じ数のパラメータを持ち、戻り値は`void`型です。異なるのはパラメータの型だけで、`fn3`のパラメータは`Person`型であり、`fn4`のパラメータは`Student`型。パラメータの互換性を確認すると、「`fn4`のパラメータの型(Student) <: `fn3`のパラメータの型(Person)」という関係にあるため、`fn4`を`fn3`に代入することはできない。しかし、その逆は互換性の条件を満たすので代入可能。パラメータ名は同じである必要がある。

&emsp;`fn4 = fn3`の代入後、`fn4`を呼び出す際には、`Student`型のオブジェクトを引数として渡す必要がある。このとき、`fn4`には`fn3`が代入されているため、`fn3`に引数が渡され実行される。`fn3`に渡される引数には`Person`型にはない`club`プロパティが含まれるが、関数の内部で使用していないので無視しても問題ない。

&emsp;仮に、互換性を判定する条件としてのパラメータの型関係が逆になっていたとすれば、期待されるプロパティを持つオブジェクトが渡されることが保証されなくなり、安全でなくなることがわかる。例として、`fn3 = fn4`が許されれば、`fn3`を呼び出すと、`fn3`に代入されている`fn4`に、`Person`型の引数が渡ることになる。

## パラメータの数と関数型の互換性

:::code-group
```ts [index.ts]
interface Person {
  name: string
  age: number
}

let fn3 = (person: Person) => {
  console.log(`That person's name is ${person.name} (${person.age})`)
}

let fn5 = (person: Person, gender: string) => {
  console.log(`That person's name is ${person.name}(${person.age}), ${gender}`)
}

// NG. fn3のパラメータの数 < fn5のパラメータの数 なので条件を満たさない。
// fn3 = fn5
// 型 '(person: Person, gender: string) => void' を型 '(person: Person) => void' に割り当てることはできません。
// ターゲット署名の引数が少なすぎます。2 以上が必要ですが、1 でした。

// OK
fn5 = fn3

// fn5は関数型としてパラメータを2つ持つため、引数を2つ渡す必要がある。
fn5({ name: 'John', age: 20 }, 'fmale') // OK

// NG
// fn5({ name: 'John', age: 20 })
// 2 個の引数が必要ですが、1 個指定されました。
```
:::

&emsp;上記の例では、`fn5`は、`fn3`と同じ`Person`型のパラメータに加えて、`string`型のパラメータを持つ。どちらの関数も戻り値は`void`型で、異なるのはパラメータの数だけ。互換性を確認すると、`fn5`のパラメータ数が`fn3`より多いため、`fn5`を`fn3`に代入することはできない。その逆は互換性の条件を満たすので代入可能。

&emsp;`fn5 = fn3`として、`fn5`を実行する際は、`Person`型の引数に加えて、`string`型の引数も渡す必要がある。それらの引数は、`fn5`に代入されている`fn3`に渡り実行される。`fn3`のパラメータにはない`string`型の引数が渡ってくるが、この引数は無視される。この引数は関数の内部で使用していないので無視して問題ない。

&emsp;仮に互換性に関するパラメータの数の関係が逆になっていたら、必要な引数が渡ってくることが保証されなくなり安全でなくなる。

## 関数型の互換性

:::code-group
```ts [index.ts]
interface Person {
  name: string
  age: number
}

// インターフェイスの拡張によって、自動的にStudentはPersonのサブタイプになる
interface Student extends Person {
  club: string
}

// Studentインターフェイスの構造
// {
//   name: string
//   age: number
//   club: string
// }

let fn3 = (person: Person) => {
  console.log(`That person's name is ${person.name} (${person.age})`)
}

let fn6 = (student: Student, gender: string) => {
  console.log(
    `That student's name is ${student.name} (${student.age}), ${gender} and enjoys ${student.club}`,
  )
}

// OK
fn6 = fn3
// fn6のパラメータの型 <: fn3のパラメータの型
// fn3のパラメータの型 <: fn6のパラメータの型
```
:::

&emsp;上記の例では、`fn6`は、`fn3`と異なる型のパラメータを持ち、さらにパラメータの数も異なるが、`fn3`を`fn6`に代入することは可能。これは、`fn3`のパラメータの型が`fn6`のそれに対するスーパータイプであり、`fn3`のパラメータの数が`fn6`のそれより少ないため。

&emsp;関数Aと関数Bにおいて、次の条件がすべて満たされる場合、関数Bは関数Aのサブタイプとなる。

- 各パラメータにおいて、「Aのパラメータの型 <: Bのパラメータの型」
- Bのパラメータ数 <= Aのパラメータ数
- Bの戻り値の型 <: Aの戻り値の型