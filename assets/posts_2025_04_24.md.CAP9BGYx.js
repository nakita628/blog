import{_ as a,C as l,c as g,o as n,j as t,b as i,a7 as c,a as e,w as o,G as p,a8 as d}from"./chunks/framework.CbZ0TyXs.js";const _=JSON.parse('{"title":"Clean Architecture オープン・クローズドの原則","description":"Clean Architecture オープン・クローズドの原則","frontmatter":{"date":"2025-04-24T00:00:00.000Z","title":"Clean Architecture オープン・クローズドの原則","description":"Clean Architecture オープン・クローズドの原則","tags":["Clean Architecture"],"prev":{"text":"Clean Architecture 単一責任の原則","link":"/posts/2025/04/23"},"next":{"text":"Clean Architecture リスコフの置換原則","link":"/posts/2025/04/25"}},"headers":[],"relativePath":"posts/2025/04/24.md","filePath":"posts/2025/04/24.md"}'),u={name:"posts/2025/04/24.md"};function C(h,r,m,A,P,I){const s=l("Mermaid");return n(),g("div",null,[r[1]||(r[1]=t("h1",{id:"clean-architecture-オープン・クローズドの原則",tabindex:"-1"},[e("Clean Architecture オープン・クローズドの原則 "),t("a",{class:"header-anchor",href:"#clean-architecture-オープン・クローズドの原則","aria-label":'Permalink to "Clean Architecture オープン・クローズドの原則"'},"​")],-1)),r[2]||(r[2]=t("ul",null,[t("li",null,"ソフトウェアの構成要素は拡張に対しては開いていて、修正に対して閉じていなければならない。")],-1)),r[3]||(r[3]=t("p",null," 言い換えれば、ソフトウェアの振る舞いは、既存の成果物を変更せずに拡張できるようにすべきである、ということ。",-1)),r[4]||(r[4]=t("h2",{id:"コンポーネントの関係は単方向",tabindex:"-1"},[e("コンポーネントの関係は単方向 "),t("a",{class:"header-anchor",href:"#コンポーネントの関係は単方向","aria-label":'Permalink to "コンポーネントの関係は単方向"'},"​")],-1)),(n(),i(d,null,{default:o(()=>[p(s,{id:"mermaid-16",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20View%20--%3E%20Presenter%0A%20%20%20%20Presenter%20--%3E%20Controller%0A%20%20%20%20Controller%20--%3E%20Interactor%0A%20%20%20%20Interactor%20--%3E%20Database%0A"})]),fallback:o(()=>[...r[0]||(r[0]=[e(" Loading... ",-1)])]),_:1})),r[5]||(r[5]=c('<p> コンポーネントAがコンポーネントBの変更から保護されるべきならば、コンポーネントBからコンポーネントA併存すべきである。</p><p> ここでは、<strong>Presenter</strong>を変更した時に、<strong>Controller</strong>を変更する必要をなくしたい。<strong>Views</strong>を変更した時に、<strong>Presenter</strong>を変更する必要をなくしたい。<strong>他のすべて</strong>を変更したときに、<strong>Interactor</strong>を変更する必要をなくしたい。</p><p> オープン・クローズドの原則(OCP)に最も適しているのは、<strong>Interactor</strong>である。<strong>Database</strong>、<strong>Controller</strong>、<strong>Presenter</strong>、<strong>View</strong>を変更しても、<strong>Interactor</strong>には何の影響も及ぶさない。</p><p> <strong>Interactor</strong>が特権的な位置づけになるのは、ビジネスルールを含んでいるからである。<strong>Interactor</strong>は、アプリケーションの最上位レベルの方針を含んでいる。その他のコンポーネントは、周辺にある関心事を処理。<strong>Interactor</strong>は、その中心となる関心事を処理。</p><p> <strong>Controller</strong>は、<strong>Interactor</strong>の周辺にある関心事だが、その一方で<strong>Presenter</strong>や<strong>View</strong>に対しては中心点な位置づけになる。<strong>Presenter</strong>も、<strong>Controller</strong>に対しては周辺的だが、<strong>View</strong>に対しては中心的な位置づけになる。</p><p> <strong>Interactor</strong>は最上位レベルの概念なので、最も保護される。<strong>View</strong>は最下位レベルの概念なので、保護レベルは最も低くなる。<strong>Presenter</strong>は、<strong>View</strong>よりも上位にあるが、<strong>Controller</strong>や<strong>Interactor</strong>よりも下位レベルにある概念。</p><p> これが、アーキテクチャレベルにおけるオープン・クローズドの原則(OCP)。アーキテクトは、いつどのような理由でどのように変更するかを考えて機能を分割する。そして、分割した機能をコンポーネントの階層構造にまとめる。上位レベルにあるコンポーネントは、下位レベルのコンポーネントが変更されたとしても、変更する必要はない。</p><h2 id="情報隠蔽" tabindex="-1">情報隠蔽 <a class="header-anchor" href="#情報隠蔽" aria-label="Permalink to &quot;情報隠蔽&quot;">​</a></h2><p> <strong>Controller</strong>への変更が<strong>Interactor</strong>に影響を及ぼさないようにすることが最優先だが、<strong>Controller</strong>もまた<strong>Interactor</strong>の変更から保護しておきたいので、<strong>Interactor</strong>の内部を隠蔽している。</p><h2 id="まとめ" tabindex="-1">まとめ <a class="header-anchor" href="#まとめ" aria-label="Permalink to &quot;まとめ&quot;">​</a></h2><p> オープン・クローズドの原則(OCP)は、システムのアーキテクきゃの隠れた原動力。目的は、変更の影響を受けずにシステムを拡張しやすくすること。目的を達成するために、システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にする。そして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする。</p>',11))])}const V=a(u,[["render",C]]);export{_ as __pageData,V as default};
