import{_ as e,c as a,o as r,a7 as c}from"./chunks/framework.CbZ0TyXs.js";const _=JSON.parse('{"title":"Clean Architecture 依存関係逆転の原則","description":"Clean Architecture 依存関係逆転の原則","frontmatter":{"date":"2025-04-27T00:00:00.000Z","title":"Clean Architecture 依存関係逆転の原則","description":"Clean Architecture 依存関係逆転の原則","tags":["Clean Architecture"],"prev":{"text":"Clean Architecture インターフェイス分離の原則","link":"/posts/2025/04/26"},"next":{"text":"Clean Architecture コンポーネントの原則","link":"/posts/2025/04/28"}},"headers":[],"relativePath":"posts/2025/04/27.md","filePath":"posts/2025/04/27.md"}'),l={name:"posts/2025/04/27.md"};function i(n,t,o,s,p,u){return r(),a("div",null,[...t[0]||(t[0]=[c('<h1 id="clean-architecture-依存関係逆転の原則" tabindex="-1">Clean Architecture 依存関係逆転の原則 <a class="header-anchor" href="#clean-architecture-依存関係逆転の原則" aria-label="Permalink to &quot;Clean Architecture 依存関係逆転の原則&quot;">​</a></h1><ul><li>変化しやすい具象クラスを参照しない。</li></ul><p> その代わりに抽象インターフェイスを参照すること。静的型付け言語であっても動的型付け言語であっても、このルールは守る。これはオブジェクトの生成時にも大きな制約となる。一般的には、<strong>Abstract Factory</strong>パターンを使用するしかない。</p><ul><li>変化しやすい具象クラスを継承しない。</li></ul><p> 静的型付け言語における継承は、ソースコードの関係のなかで最も強力かつ厳格なもの。そのため、十分に注意しながら使う必要がある。動的型付け言語であればそれほど問題にならないが、継承が一種の依存関係であることは変わらないので、気をつけて使うのが賢明。</p><ul><li>具象関数をオーバーライドしない。</li></ul><p> 具象関数はソースコードの依存を要求することが多い。関数をオーバーライドしても依存関係を排除することはできず、そのまま継承することになる。依存をうまく管理するには、元の関数を抽象関数にして、それに対する複数の実装を用意しなければいけない。</p><ul><li>変化しやすい具象を名指しで参照しない。</li></ul><p>依存関係逆転の原則(DIP)を言い換えたもの。</p><h2 id="factory" tabindex="-1">Factory <a class="header-anchor" href="#factory" aria-label="Permalink to &quot;Factory&quot;">​</a></h2><p> 上記のルールに従おうとすると、具象オブジェクトを生成する際に特別な処理が必要になる。事実上すべての言語において、オブジェクトの生成にはオブジェクトの具象定義を含むソースコードへの依存が避けられない。</p>',11)])])}const d=e(l,[["render",i]]);export{_ as __pageData,d as default};
