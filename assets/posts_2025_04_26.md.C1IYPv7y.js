import{_ as d,C as s,c as l,o,a7 as i,b as n,j as a,w as t,a as r,G as p,a8 as m}from"./chunks/framework.BK-5gBo2.js";const g=JSON.parse('{"title":"Clean Architecture インターフェイス分離の原則","description":"Clean Architecture インターフェイス分離の原則","frontmatter":{"date":"2025-04-26T00:00:00.000Z","title":"Clean Architecture インターフェイス分離の原則","description":"Clean Architecture インターフェイス分離の原則","tags":["Clean Architecture"],"prev":{"text":"Clean Architecture リスコフの置換原則","link":"/posts/2025/04/25"},"next":{"text":"Clean Architecture 依存関係逆転の原則","link":"/posts/2025/04/27"}},"headers":[],"relativePath":"posts/2025/04/26.md","filePath":"posts/2025/04/26.md"}'),u={name:"posts/2025/04/26.md"};function h(C,e,S,A,E,B){const c=s("Mermaid");return o(),l("div",null,[e[1]||(e[1]=i('<h1 id="clean-architecture-インターフェイス分離の原則" tabindex="-1">Clean Architecture インターフェイス分離の原則 <a class="header-anchor" href="#clean-architecture-インターフェイス分離の原則" aria-label="Permalink to &quot;Clean Architecture インターフェイス分離の原則&quot;">​</a></h1><h2 id="インターフェイス分離の原則" tabindex="-1">インターフェイス分離の原則 <a class="header-anchor" href="#インターフェイス分離の原則" aria-label="Permalink to &quot;インターフェイス分離の原則&quot;">​</a></h2><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU9ApaaiBbRm3mXMgEPI00Bj_0933KqOqmZ1D0OoQs7gGujJYmoHs4P8R6CkBh2qWgwk7SXWCCy8XMSCvt4vfEQb01q20000" alt="uml diagram"><p> 複数のユーザーが同じ<code>OPS</code>クラスを使用している。ここでは、<code>User1</code>が<code>op1</code>を使い、<code>User2</code>が<code>op2</code>を使い、<code>User3</code>が<code>op3</code>を使用しているものとする。</p><p> <code>User1</code>のソースコードは、実際には使っていない<code>op2</code>と<code>op3</code>にも意図せずに依存。ここでいう「依存」とは、<code>op2</code>のコードを変更したときに、<code>User1</code>の再コンパイルと際デプロイが必要になるという意味。本来ならば、<code>op2</code>のコードが変わっても気にする必要はない。</p><p> この問題を解決するには、各操作をインターフェイスに分離する。</p><p> <code>User1</code>のソースコードは<code>U1Ops</code>と<code>op1</code>には依存しているが、<code>OPS</code>には依存していない。つまり、<code>OPS</code>に変更があったとしても、もしそれが<code>User1</code>に関係のない部分であれば、<code>User1</code>の再コンパイルと再デプロイは不要になる。</p><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuUBAp2j9BKfBJ4vLy0y8LgZcKW02xVm2GmrD6DC8mJG6CckHzOGQ-XSKe-f2bJT2aJV2a3T6aOUQdvoJM5oi45gSMcI8n3P2OXjpSK6ijgdHrGMvd0jY4u9hZCBb0XkceAjh1t4oc6y4uHl1-COGFaWd5vT3QbuAC800" alt="uml diagram"><h2 id="インターフェイス分離の原則-isp-とアーキテクチャとの関係" tabindex="-1">インターフェイス分離の原則(ISP)とアーキテクチャとの関係 <a class="header-anchor" href="#インターフェイス分離の原則-isp-とアーキテクチャとの関係" aria-label="Permalink to &quot;インターフェイス分離の原則(ISP)とアーキテクチャとの関係&quot;">​</a></h2><p> システムSを担当するアーキテクトが、あるフレームワークFをシステムに導入したいと考えたとする。このフレームワークFの作者は、フレームワークを特定のデータベースDのためだけに作っている。つまりSはFに依存しており、さらにFはDに依存していることになる。</p><h2 id="問題のあるアーキテクチャ" tabindex="-1">問題のあるアーキテクチャ <a class="header-anchor" href="#問題のあるアーキテクチャ" aria-label="Permalink to &quot;問題のあるアーキテクチャ&quot;">​</a></h2>',11)),(o(),n(m,null,{default:t(()=>[p(c,{id:"mermaid-29",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20S%5B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0S%5D%20--%3E%20F%5B%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AFF%5D%20--%3E%20D%5B%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9D%5D%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[r(" Loading... ",-1)])]),_:1})),e[2]||(e[2]=a("p",null," FがDのすべての機能を使っているわけではなく、使っていない機能もある。Sにとって、それらの機能はどうでもいい。だが、Dのそのような部分が更新されると、Fは再デプロイすることになる。それはすなわち、Sも再デプロイしなければいけないということ。Dの一部の機能に障害が発生すると、それがFやSの障害の原因になってしまう可能性がある。",-1)),e[3]||(e[3]=a("h2",{id:"まとめ",tabindex:"-1"},[r("まとめ "),a("a",{class:"header-anchor",href:"#まとめ","aria-label":'Permalink to "まとめ"'},"​")],-1)),e[4]||(e[4]=a("p",null," 必要としないお荷物を抱えたものに依存していると、予期せぬトラブルの元につながる。",-1))])}const _=d(u,[["render",h]]);export{g as __pageData,_ as default};
