import{_ as i,c as t,o as a,a7 as r}from"./chunks/framework.BK-5gBo2.js";const u=JSON.parse('{"title":"Clean Architecture 設計の原則","description":"Clean Architecture 設計の原則","frontmatter":{"date":"2025-04-22T00:00:00.000Z","title":"Clean Architecture 設計の原則","description":"Clean Architecture 設計の原則","tags":["Clean Architecture"],"prev":{"text":"Clean Architecture 関数型プログラミング","link":"/posts/2025/04/21"},"next":{"text":"Clean Architecture 単一責任の原則","link":"/posts/2025/04/23"}},"headers":[],"relativePath":"posts/2025/04/22.md","filePath":"posts/2025/04/22.md"}'),n={name:"posts/2025/04/22.md"};function l(p,e,c,o,s,d){return a(),t("div",null,[...e[0]||(e[0]=[r('<h1 id="clean-architecture-設計の原則" tabindex="-1">Clean Architecture 設計の原則 <a class="header-anchor" href="#clean-architecture-設計の原則" aria-label="Permalink to &quot;Clean Architecture 設計の原則&quot;">​</a></h1><h2 id="solid原則" tabindex="-1">SOLID原則 <a class="header-anchor" href="#solid原則" aria-label="Permalink to &quot;SOLID原則&quot;">​</a></h2><ul><li><p>変更に強いこと</p></li><li><p>理解しやすいこと</p></li><li><p>コンポーネントの基盤として、多くのソフトウェアシステムで利用できること</p></li></ul><h2 id="単一責任の原則-srp-single-responsibility-principle" tabindex="-1">単一責任の原則(SRP : Single Responsibility Principle) <a class="header-anchor" href="#単一責任の原則-srp-single-responsibility-principle" aria-label="Permalink to &quot;単一責任の原則(SRP : Single Responsibility Principle)&quot;">​</a></h2><p> 個々のモジュールを変更する理由がたった一つだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。</p><h2 id="オープン・クローズドの原則-cop-open-closed-principle" tabindex="-1">オープン・クローズドの原則(COP : Open-Closed Principle) <a class="header-anchor" href="#オープン・クローズドの原則-cop-open-closed-principle" aria-label="Permalink to &quot;オープン・クローズドの原則(COP : Open-Closed Principle)&quot;">​</a></h2><p> ソフトウェアを変更しやすくするために、既存のコードの変更よりも新しいコードの追加によって、システムの振る舞いを変更できるように設計すべき。</p><h2 id="リコリフの原則-lsp-liskov-substitution-principle" tabindex="-1">リコリフの原則(LSP : Liskov Substitution Principle) <a class="header-anchor" href="#リコリフの原則-lsp-liskov-substitution-principle" aria-label="Permalink to &quot;リコリフの原則(LSP : Liskov Substitution Principle)&quot;">​</a></h2><p> 交換可能なパーツを使用し、ソフトウェアシステムを構築するなら、個々のパーツが交換可能になるような契約に従わなければならない。</p><h2 id="インターフェイス分離の原則-isp-interface-segregation-principle" tabindex="-1">インターフェイス分離の原則(ISP : Interface Segregation Principle) <a class="header-anchor" href="#インターフェイス分離の原則-isp-interface-segregation-principle" aria-label="Permalink to &quot;インターフェイス分離の原則(ISP : Interface Segregation Principle)&quot;">​</a></h2><p> ソフトウェアを設計する際には、使っていないものへの依存を回避すべきだという原則。</p><h2 id="依存関係逆転の原則-dip-dependency-inversion-principle" tabindex="-1">依存関係逆転の原則(DIP : Dependency Inversion Principle) <a class="header-anchor" href="#依存関係逆転の原則-dip-dependency-inversion-principle" aria-label="Permalink to &quot;依存関係逆転の原則(DIP : Dependency Inversion Principle)&quot;">​</a></h2><p> 上位レベルの方針の実装コードは、下位レベルの詳細の実装コードに依存すべきではなく、逆に詳細側が方針に依存すべきであるという原則。</p>',13)])])}const P=i(n,[["render",l]]);export{u as __pageData,P as default};
